# 易用性改进  

## 初始化  

### 类内成员变量初始化  

```c++
class B;

class A
{
public:
    int data1 = 1;
    int data2{2};
    B data3{3};
    string data4{"4"};
};

class B
{
public:
    B(int i): m_i(i) {}

    int m_i;
};

int main()
{
    A a;
    cout << a.data1 << endl;    // 1
    cout << a.data2 << endl;    // 2
    cout << a.data3.m_i << endl;// 3
    cout << a.data4 << endl;    // 4

    return 0;
}
```

### 列表初始化  

```c++
struct Test
{
    int a;
    double b;
    char c[10];
};

int main()
{
    int a{1};
    int b = {1};
    Test test = {1, 1.3, "name"};
    int arr1[] = {1, 2};
    int arr2[]{1, 2};

    return 0;
}
```

## 基于范围的for循环  

```c++
vector<int> v;
for (int i = 1; i < 5; i++)
{
    v.push_back(i);
}

for (auto& tmp: v)
{
    tmp *= 2;
}

for (auto tmp: v)
{
    cout << tmp << " ";
}
cout << endl; //2 4 6 8
```

## 静态断言  

```c++
// assert 在运行时检查条件，如果条件为真，则继续执行，否则终止
bool cond = false;
assert(cond); // Assertion failed!

// 静态断言可以在编译时就判断条件，减小开销
// static_assert(常量表达式条件, "提示的字符串");
static_assert(sizeof(void*) == 4, "32位"); // 64位会编译时报错
```

## noexcept  

```c++
// 下面两种写法都是该函数不抛出任何异常
void func1() throw() {   }
void func2() noexcept {   }
```

## nullptr  

```c++
// nullptr为了解决NULL的二义性
int a = NULL;
int* pa = NULL;

int *pb = nullptr;
// int b = nullptr; // 报错

if (pa == pb)
    cout << "equal" << endl; // equal
```

## 常量表达式（constexpr)  

```c++
// 常量表达式允许一些计算发生在编译阶段，它将只做一次，而不是每次程序运行时都计算
// constexpr的限制：
// 函数中只能有一个语句，且为return语句，函数必须有返回值
// 但是函数中允许包含typedef, using, 静态断言
// return 语句中不能使用非常量表达式的函数，全局数据，只能是一个常量表达式

constexpr int getConst1()
{
    return 4 + 104;
}

constexpr int getConst2()
{
    //constexpr int a = 1; // 报错
    return 6;
}

constexpr int getConst3()
{
    typedef int INT;
    return 4;
}

const int aa = 6;
constexpr int getConst4()
{
    // return a;  // 报错
}

int getINT()
{
    return 4;
}
constexpr int getConst5()
{
    //return getINT(); // 报错
}

int main()
{
    int a = getConst1();
    cout << a << endl;

    return 0;
}
```
