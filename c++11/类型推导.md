# 类型推导  

## auto  

```c++
// 注意：auto在定义变量时，必须初始化
// 有些IDE不支持函数形参是auto变量
// auto变量不能作为自定义类型的成员变量。比如struct test{auto a = 10;};
// 不能定义auto数组。比如，auto b[2] = {1, 2};
// 模板实例化类型不能是auto类型。比如，vector<auto> b = {1};

auto a = 1; // int
auto b = 1.444; // double

vector<int> v(5, 10);
for (auto it = v.begin(); it != v.end(); it++)
    cout << *it << " ";
cout << endl; // 10 10 10 10 10
```

## decltype  

```c++
// decltyp用来获取变量的类型
int i;
decltype(i) j = 0;
cout << typeid(j).name() << endl; // i(int)

// decltype(a + b)
float a;
double b;
decltype(a + b)c;
cout << typeid(c).name() << endl; // d(double)

// 迭代器
vector<int> v(5, 10);
decltype(v.begin()) k;
for (k = v.begin(); k != v.end(); k++)
    cout << *k << " ";
cout << endl; // 10 10 10 10 10
```

## 追踪返回类型  

```c++
// auto返回值与->(?)一起使用，表明该函数返回值可以根据->后面的要求自动推导

auto func1(int a, double b) -> int
{
    return a + b;
}

auto func2(int a, double b) -> double
{
    return a + b;
}

auto func3(int a, double b) -> decltype(a + b)
{
    return a + b;
}

// 在结合模板使用的时候，会有更大的作用

template<class T1, class T2>
auto mul(T1& t1, T2& t2) -> decltype(t1 * t2)
{
    return t1 * t2;
}

int main()
{
    auto a = 10;
    auto b = 11.1;
    cout << func1(a, b) << endl; // 21
    cout << func2(a, b) << endl; // 21.1
    cout << func3(a, b) << endl; // 21.1

    auto c = 10;
    auto d = 11.11;
    cout << mul(c, d) << endl; // 111.1

    return 0;
}
```
