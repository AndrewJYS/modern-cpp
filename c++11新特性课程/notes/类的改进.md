# 类的改进  

## 委托构造  

```c++
class Test
{
public:
    // 委托构造一定要通过初始化列表方式
    Test(): Test(1, 'a') {}
    Test(int x): Test(x, 'b') {}
    Test(char x): Test(11, x) {}

    int a;
    char b;

private:
    Test(int x, char y): a(x), b(y) {}
};

int main()
{
    Test t1;
    cout << t1.a << endl; // 1
    cout << t1.b << endl; // a

    Test t2(10);
    cout << t2.a << endl; // 10
    cout << t2.b << endl; // b

    Test t3('c');
    cout << t3.a << endl; // 11
    cout << t3.b << endl; // c

    return 0;
}
```

## final  

```c++
// final会阻止类的进一步派生，虚函数的进一步重写

class A1 final
{
    int a;
};

// class A2: public A1; //无法继承，报错

class B1
{
public:
    virtual void run() final;
};

class B2: public B1
{
    // void run() {} // 无法重写，报错
};
```

## override  

```c++
class C1
{
public:
    // 这是第一个虚函数，没有重写，不能用override修饰
    virtual void run(int a) = 0;
};

class C2: public C1
{
public:
    // 在重写虚函数的地方，加上override，要求重写的虚函数和基类一模一样
    void run(int a) override {}
    //void run() override {} // 报错
    //int run() override {return 1;} // 报错
};
```

## 类默认函数的使用（=default，=delete）  

```c++
class B
{
public:
    B() { cout << "无参构造函数" << endl; }
    B(const B&) { cout << "拷贝构造函数" << endl; }
    B& operator=(const B& ) {cout << "赋值运算符重载函数" << endl; return *this; }
};

class C
{
public:
    // =delete 可以禁用函数，也可以禁用一般函数
    C() { cout << "无参构造函数" << endl; }
    C(const C&)=delete; // 用=delete修饰，此函数被禁用
    C& operator=(const C& )=delete;

    // =delete还可以禁用运算符
    void* operator new(size_t)=delete;
    void* operator new[](size_t)=delete;
};

int main()
{
    B obj1;
    B obj2(obj1);
    obj2 = obj1;

    C obj3;
    // C obj4(obj3); // 报错，拷贝构造函数被禁用

    //C* p = new C; // 报错，new运算符被禁用
    //C* parr = new C[10]; // 报错，new[]运算符被禁用

    return 0;
}
```
