# 移动语义  

## 为什么需要移动语义  

右值引用是用来支持移动语义的。移动语义可以将资源（堆，系统对象等）从一个对象转到另一个对象，这样就避免了不必要的临时对象的创建、拷贝和销毁，从而大幅提高程序性能。下面例子中，不同编译器会有不同的结果，有些编译器并没有优化到最佳性能。为了保证优化到下例的最佳性能，应该使用移动语义。  

```c++
class MyString
{
public:
    MyString(char* tmp = "abc")
    {
        m_len = strlen(tmp);
        m_string = new char[m_len + 1];
        strcpy(m_string, tmp);

        cout << "含参构造函数，tmp = " << tmp << endl;
    }

    MyString(const MyString& tmp)
    {
        m_len = tmp.m_len;
        m_string = new char[m_len + 1];
        strcpy(m_string, tmp.m_string);

        cout << "拷贝构造函数，tmp = " << tmp.m_string << endl;
    }

    MyString& operator=(const MyString& tmp)
    {
        if (this == &tmp) //注意不能写成*this == tmp
        {
            return *this;
        }
        //先释放原来的内存
        m_len = 0;
        delete [] m_string;

        // 重新申请内容
        m_len = tmp.m_len;
        m_string = new char[this->m_len + 1];
        strcpy(m_string, tmp.m_string);

        cout << "赋值运算符重载，tmp = " << tmp.m_string << endl;

        return *this;
    }

    ~MyString()
    {
        cout << "析构函数: ";
        if (this != NULL)
        {
            delete [] m_string;
            m_string = NULL;
            m_len = 0;
            cout << "已操作delete" << endl;
        }
    }

private:
    int     m_len;
    char*   m_string;
};

MyString func()
{
    MyString tmp("mike");
    return tmp;
}

int main()
{
    MyString tmp = func();
    //含参构造函数，tmp = mike
    //析构函数: 已操作delete

    return 0;
}
```

## 移动构造函数  

使用移动构造函数后，上述例子即使在最坏情况下，也不会额外申请空间  

```c++
class MyString
{
public:
......
    //移动构造函数
    //参数是非const的右值引用
    MyString(MyString && t)
    {
        m_string = t.m_string; //拷贝地址，没有重新申请内存
        m_len = t.m_len;
        t.m_string = NULL;  // 原指针置空
        cout << "移动构造函数" << endl;
    }
......

int main()
{
    MyString && tmp2 = func(); // 右值引用接收，引发“移动构造函数”

    //因此，在编译器不优化的情况下，函数的调用如下
    // 含参构造函数
    // 移动构造函数
    // 析构函数（不需要delete）
    // 析构函数（这是main函数结束后，需要delete）

    return 0;
}
```

## 移动赋值函数  

如果按照上述MyString类的代码，那么下面几行代码会调用多次函数（若编译器没有优化），分别为：  

```c++
MyString tmp("abcd")调用含参构造函数
MyString obj("mike")调用含参构造函数
在return obj时调用移动构造函数，生成一个临时对象
func()调用完毕，obj释放，调用析构函数，无需delete
tmp = func()中，新的临时变量给tmp赋值，调用运算符重载函数
赋值完后，临时对象的生命周期结束，调用析构函数，需要delete
main函数结束，调用析构函数，tmp释放，需要delete
```

```c++
MyString func()
{
    MyString obj("mike");
    return obj;
}

int main()
{
    MyString tmp("abcd");
    tmp = func();
    return 0;
}
```

可以用移动赋值函数优化编译过程。在编译器不优化的情况下，下述代码会调用这些函数：  

```c++
MyString tmp("abcd")调用含参构造函数
MyString obj("mike")调用含参构造函数
在return obj时调用移动构造函数，生成一个临时对象
func()调用完毕，obj释放，调用析构函数，无需delete
tmp = func()中，调用移动赋值函数
赋值完后，调用析构函数，无需delete
main函数结束，调用析构函数，tmp释放，需要delete
```

可以看到，移动赋值函数对应的析构函数无需调用delete，因此提高了性能  

```c++
// 移动赋值函数
// 无需重新申请堆区
MyString& operator=(MyString && t)
{
    if (this == &t)
    {
        return *this;
    }

    //先释放原来的内存
    m_len = 0;
    delete [] m_string;

    // 无需重新申请堆区
    m_string = t.m_string; //拷贝地址，没有重新申请内存
    m_len = t.m_len;
    t.m_string = NULL;  // 原指针置空

    cout << "移动赋值函数" << endl;

    return *this;
}
```

## std::move函数  

move()函数将左值转换成右值  

```c++
int a = 10; // a为左值
//int && b = a; // error
int && c = std::move(a);
cout << c << endl;
```
